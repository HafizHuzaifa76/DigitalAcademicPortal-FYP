import 'package:get/get.dart';
import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart' as file_picker;
import 'package:path/path.dart' as path;
import 'dart:io';
import '../../../../../../core/services/NotificationService.dart';
import '../../domain/entities/UploadedFile.dart';
import '../../domain/usecases/GetUploadedFilesUseCase.dart';
import '../../domain/usecases/UploadFileUseCase.dart';
import '../../domain/usecases/DeleteFileUseCase.dart';
import '../../../teacher_courses/domain/entities/TeacherCourse.dart';
import '../../../../../../core/utils/Utils.dart';
import '../../../../../../core/services/CloudinaryService.dart';

class UploadedFileController extends GetxController {
  final GetUploadedFilesUseCase getFilesUseCase;
  final UploadFileUseCase uploadFileUseCase;
  final DeleteFileUseCase deleteFileUseCase;

  UploadedFileController({
    required this.getFilesUseCase,
    required this.uploadFileUseCase,
    required this.deleteFileUseCase,
  });

  final files = <UploadedFile>[].obs;
  final isLoading = false.obs;
  final isUploading = false.obs;

  @override
  void onInit() {
    super.onInit();
    // Clear any existing files when controller is initialized
    files.clear();
  }

  @override
  void onClose() {
    // Don't clear files on close since we want to keep the controller alive
    super.onClose();
  }

  void clearFiles() {
    files.clear();
    isLoading.value = false;
    isUploading.value = false;
  }

  Future<void> getFiles(TeacherCourse course, FileType type) async {
    isLoading.value = true;
    final result = await getFilesUseCase
        .execute(GetFilesParams(course: course, type: type));
    result.fold(
      (failure) {
        Utils().showErrorSnackBar('Error', failure.failure.toString());
        isLoading.value = false;
      },
      (data) {
        files.value = data;
        isLoading.value = false;
      },
    );
  }

  Future<void> uploadFile(TeacherCourse course, FileType type) async {
    try {
      file_picker.FilePickerResult? pickerResult =
          await file_picker.FilePicker.platform.pickFiles(
        type: file_picker.FileType.custom,
        allowedExtensions: _getAllowedExtensions(type),
      );

      if (pickerResult != null) {
        isUploading.value = true;

        // Get the file path
        String? filePath = pickerResult.files.single.path;
        if (filePath == null) {
          Utils().showErrorSnackBar('Error', 'Could not access file path');
          isUploading.value = false;
          return;
        }

        // Upload file to Cloudinary
        File file = File(filePath);
        String? fileUrl = await uploadFileToCloudinary(file);

        if (fileUrl == null) {
          Utils().showErrorSnackBar(
              'Error', 'Failed to upload file to cloud storage');
          isUploading.value = false;
          return;
        }

        final uploadedFile = UploadedFile(
          id: '', // Will be generated by Firestore
          fileName: path.basename(pickerResult.files.single.name),
          fileUrl: fileUrl,
          fileSize: pickerResult.files.single.size ?? 0,
          uploadDate: DateTime.now(),
          type: type,
          courseId: course.courseName,
          courseName: course.courseName,
          courseSection: course.courseSection,
        );

        final uploadResult = await uploadFileUseCase
            .execute(UploadFileParams(course: course, file: uploadedFile));
        uploadResult.fold(
          (failure) {
            Utils().showErrorSnackBar('Error', failure.failure.toString());
            isUploading.value = false;
          },
          (_) async {
            // Refresh the files list
            getFiles(course, type);
            Utils()
                .showSuccessSnackBar('Success', 'File uploaded successfully');
                
          final sectionTopic =
              'Section-${course.courseSemester}-${course.courseSection}';
          await sendFCMMessage(
              sectionTopic,
              'Course Material',
              'New ${getFileTypeDisplayName(type)} Material have been Uploaded for ${course.courseName}',
              'student_gradesScreen');

            isUploading.value = false;
          },
        );
      }
    } catch (e) {
      Utils().showErrorSnackBar('Error', 'Failed to upload file: $e');
      isUploading.value = false;
    }
  }

  Future<void> deleteFile(
      String fileId, TeacherCourse course, FileType type) async {
    final result = await deleteFileUseCase
        .execute(DeleteFileParams(course: course, fileId: fileId));
    result.fold(
      (failure) {
        Utils().showErrorSnackBar('Error', failure.failure.toString());
        print(failure.failure.toString());
      },
      (_) {
        // Refresh the files list
        getFiles(course, type);
        Utils().showSuccessSnackBar('Success', 'File deleted successfully');
      },
    );
  }

  List<String> _getAllowedExtensions(FileType type) {
    switch (type) {
      case FileType.resource:
        return ['zip', 'rar', 'xls', 'docx', 'pdf', 'ppt', 'doc'];
      case FileType.lectureSlide:
        return ['pdf', 'ppt', 'doc', 'pptx', 'docx'];
      case FileType.syllabus:
        return ['pdf'];
    }
  }

  String getFileTypeDisplayName(FileType type) {
    switch (type) {
      case FileType.resource:
        return 'Resource';
      case FileType.lectureSlide:
        return 'Lecture Slide';
      case FileType.syllabus:
        return 'Syllabus';
    }
  }

  IconData getFileTypeIcon(FileType type) {
    switch (type) {
      case FileType.resource:
        return Icons.folder;
      case FileType.lectureSlide:
        return Icons.slideshow;
      case FileType.syllabus:
        return Icons.description;
    }
  }

  IconData getFileExtensionIcon(String fileName) {
    final extension = fileName.split('.').last.toLowerCase();
    switch (extension) {
      case 'pdf':
        return Icons.picture_as_pdf;
      case 'doc':
      case 'docx':
        return Icons.description;
      case 'ppt':
      case 'pptx':
        return Icons.slideshow;
      case 'xls':
      case 'xlsx':
        return Icons.table_chart;
      case 'zip':
      case 'rar':
        return Icons.archive;
      case 'txt':
        return Icons.text_snippet;
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
        return Icons.image;
      case 'mp4':
      case 'avi':
      case 'mov':
        return Icons.video_file;
      case 'mp3':
      case 'wav':
        return Icons.audio_file;
      default:
        return Icons.insert_drive_file;
    }
  }

  Color getFileExtensionColor(String fileName) {
    final extension = fileName.split('.').last.toLowerCase();
    switch (extension) {
      case 'pdf':
        return Colors.red;
      case 'doc':
      case 'docx':
        return Colors.blue;
      case 'ppt':
      case 'pptx':
        return Colors.orange;
      case 'xls':
      case 'xlsx':
        return Colors.green;
      case 'zip':
      case 'rar':
        return Colors.purple;
      case 'txt':
        return Colors.grey;
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
        return Colors.pink;
      case 'mp4':
      case 'avi':
      case 'mov':
        return Colors.indigo;
      case 'mp3':
      case 'wav':
        return Colors.teal;
      default:
        return Colors.grey;
    }
  }
}
