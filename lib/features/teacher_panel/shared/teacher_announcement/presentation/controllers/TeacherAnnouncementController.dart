 import 'package:get/get.dart';
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../domain/entities/Announcement.dart';
import '../../domain/usecases/GetAnnouncementsUseCase.dart';
import '../../domain/usecases/CreateAnnouncementUseCase.dart';
import '../../domain/usecases/UpdateAnnouncementUseCase.dart';
import '../../domain/usecases/DeleteAnnouncementUseCase.dart';
import '../../../teacher_courses/domain/entities/TeacherCourse.dart';
import '../../../teacher_courses/domain/usecases/FetchAllTeacherCoursesUseCase.dart';
import '../../../../../../core/utils/Utils.dart';

class TeacherAnnouncementController extends GetxController {
  final GetAnnouncementsUseCase getAnnouncementsUseCase;
  final CreateAnnouncementUseCase createAnnouncementUseCase;
  final UpdateAnnouncementUseCase updateAnnouncementUseCase;
  final DeleteAnnouncementUseCase deleteAnnouncementUseCase;
  final FetchAllTeacherCoursesUseCase fetchAllTeacherCoursesUseCase;

  TeacherAnnouncementController({
    required this.getAnnouncementsUseCase,
    required this.createAnnouncementUseCase,
    required this.updateAnnouncementUseCase,
    required this.deleteAnnouncementUseCase,
    required this.fetchAllTeacherCoursesUseCase,
  });

  final announcements = <Announcement>[].obs;
  final RxList<TeacherCourse> coursesList = <TeacherCourse>[].obs;
  final isLoading = false.obs;
  final isCourseLoading = false.obs;
  final Rx<TeacherCourse?> selectedCourse = Rx<TeacherCourse?>(null);

  @override
  void onInit() {
    super.onInit();
    getTeacherCourses();
  }

  Future<void> getTeacherCourses() async {
    isCourseLoading.value = true;
    final user = FirebaseAuth.instance.currentUser;
    if (user != null && user.displayName != null) {
      List<String> parts = user.displayName!.split(' | ');
      if (parts.length > 2) {
        final String teacherDept = parts[1];
        final result = await fetchAllTeacherCoursesUseCase.execute(teacherDept);
        result.fold(
          (failure) {
            Utils().showErrorSnackBar('Error', failure.failure.toString());
          },
          (courses) {
            coursesList.value = courses;
          },
        );
      }
    }
    isCourseLoading.value = false;
  }

  void onCourseSelected(TeacherCourse course) {
    selectedCourse.value = course;
    announcements.clear();
    fetchAnnouncements();
  }

  void fetchAnnouncements() async {
    if (selectedCourse.value == null) return;
    isLoading.value = true;
    final result = await getAnnouncementsUseCase.execute(selectedCourse.value!);
    result.fold(
      (failure) {
        Utils().showErrorSnackBar('Error', failure.failure.toString());
        isLoading.value = false;
      },
      (data) {
        announcements.value = data;
        isLoading.value = false;
      },
    );
  }

  Future<void> createAnnouncement({
    required String title,
    required String content,
    required DateTime dateTime,
  }) async {
    if (selectedCourse.value == null) {
      Utils().showErrorSnackBar('Error', 'Please select a course first.');
      return;
    }

    isLoading.value = true;

    final announcement = Announcement(
      id: '', // id is generated by backend
      title: title,
      content: content,
      dateTime: dateTime,
      isPublished: true,
      courseId: selectedCourse.value!.courseName,
      courseName: selectedCourse.value!.courseName,
      courseSection: selectedCourse.value!.courseSection,
    );

    await addAnnouncement(announcement);
    isLoading.value = false;
  }

  Future<void> addAnnouncement(Announcement announcement) async {
    if (selectedCourse.value == null) return;
    isLoading.value = true;
    final result = await createAnnouncementUseCase.execute(
      CreateAnnouncementParams(
        course: selectedCourse.value!,
        announcement: announcement,
      ),
    );
    result.fold(
      (failure) {
        Utils().showErrorSnackBar('Error', failure.failure.toString());
        isLoading.value = false;
      },
      (_) {
        fetchAnnouncements(); // Refresh the list
        Get.back(); // Close dialog
        Utils().showSuccessSnackBar('Success', 'Announcement created successfully');
      },
    );
  }

  Future<void> updateAnnouncement({
    required String announcementId,
    required String title,
    required String content,
    required DateTime dateTime,
  }) async {
    if (selectedCourse.value == null) {
      Utils().showErrorSnackBar('Error', 'Please select a course first.');
      return;
    }

    isLoading.value = true;

    final announcement = Announcement(
      id: announcementId,
      title: title,
      content: content,
      dateTime: dateTime,
      isPublished: true,
      courseId: selectedCourse.value!.courseName,
      courseName: selectedCourse.value!.courseName,
      courseSection: selectedCourse.value!.courseSection,
    );

    final result = await updateAnnouncementUseCase.execute(
      UpdateAnnouncementParams(
        announcementId: announcementId,
        announcement: announcement,
      ),
    );
    result.fold(
      (failure) {
        Utils().showErrorSnackBar('Error', failure.failure.toString());
        isLoading.value = false;
      },
      (_) {
        fetchAnnouncements(); // Refresh the list
        Get.back(); // Close dialog
        Utils().showSuccessSnackBar('Success', 'Announcement updated successfully');
      },
    );
  }

  Future<void> deleteAnnouncement(String announcementId) async {
    isLoading.value = true;
    final result = await deleteAnnouncementUseCase.execute(announcementId);
    result.fold(
      (failure) {
        Utils().showErrorSnackBar('Error', failure.failure.toString());
        isLoading.value = false;
      },
      (_) {
        fetchAnnouncements(); // Refresh the list
        Utils().showSuccessSnackBar('Success', 'Announcement deleted successfully');
      },
    );
  }
}