import 'dart:io';

import 'package:digital_academic_portal/core/services/CloudinaryService.dart';
import 'package:digital_academic_portal/core/utils/Utils.dart';
import 'package:file_picker/file_picker.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_easyloading/flutter_easyloading.dart';
import 'package:get/get.dart';
import '../../../../../../core/services/NotificationService.dart';
import '../../../teacher_courses/domain/entities/TeacherCourse.dart';
import '../../domain/entities/Assignment.dart';
import '../../domain/usecases/CreateAssignmentUseCase.dart';
import '../../domain/usecases/GetAssignmentsUseCase.dart';
import '../../domain/usecases/GetTeacherCoursesUseCase.dart';
import 'package:http/http.dart' as http;
import 'package:path_provider/path_provider.dart';
import 'package:open_file/open_file.dart';
import 'dart:io';

class TeacherAssignmentController extends GetxController {
  final GetAssignmentsUseCase getAssignmentsUseCase;
  final CreateAssignmentUseCase createAssignmentUseCase;
  final GetTeacherCoursesUseCase getTeacherCoursesUseCase;

  TeacherAssignmentController({
    required this.getAssignmentsUseCase,
    required this.createAssignmentUseCase,
    required this.getTeacherCoursesUseCase,
  });

  final assignments = <Assignment>[].obs;
  final RxList<TeacherCourse> coursesList = <TeacherCourse>[].obs;
  final isLoading = false.obs;
  final isCourseLoading = false.obs;
  final Rx<TeacherCourse?> selectedCourse = Rx<TeacherCourse?>(null);
  final Rx<File?> pickedFile = Rx<File?>(null);

  @override
  void onInit() {
    super.onInit();
    getTeacherCourses();
  }

  Future<void> getTeacherCourses() async {
    isCourseLoading.value = true;
    final user = FirebaseAuth.instance.currentUser;
    if (user != null && user.displayName != null) {
      print(user.displayName);
      List<String> parts = user.displayName!.split(' | ');
      if (parts.length > 2) {
        final String teacherDept = parts[1];
        final result = await getTeacherCoursesUseCase.execute(teacherDept);
        result.fold(
          (failure) {
            Utils().showErrorSnackBar('Error', failure.failure.toString());
          },
          (courses) {
            coursesList.value = courses;
            print(coursesList.length);
          },
        );
      }
    }
    isCourseLoading.value = false;
  }

  void onCourseSelected(TeacherCourse course) {
    selectedCourse.value = course;
    assignments.clear();
    fetchAssignments();
  }

  void fetchAssignments() async {
    if (selectedCourse.value == null) return;
    isLoading.value = true;
    final result = await getAssignmentsUseCase(selectedCourse.value!);
    result.fold(
      (failure) {
        Utils().showErrorSnackBar('Error', failure.failure.toString());
        isLoading.value = false;
      },
      (data) {
        assignments.value = data;
        isLoading.value = false;
      },
    );
  }

  Future<void> pickFile() async {
    FilePickerResult? result = await FilePicker.platform.pickFiles();

    if (result != null) {
      pickedFile.value = File(result.files.single.path!);
    }
  }

  void clearPickedFile() {
    pickedFile.value = null;
  }

  Future<void> createAssignment({
    required String title,
    required String description,
    required DateTime dueDate,
  }) async {
    if (selectedCourse.value == null) {
      Utils().showErrorSnackBar('Error', 'Please select a course first.');
      return;
    }

    if (pickedFile.value == null) {
      Utils()
          .showErrorSnackBar('Error', 'Please pick a file for the assignment.');
      return;
    }

    isLoading.value = true;

    final fileUrl = await uploadFileToCloudinary(pickedFile.value!);
    if (fileUrl == null) {
      Utils().showErrorSnackBar('Error', 'Failed to upload file.');
      isLoading.value = false;
      return;
    }

    Map<String, String> studentAssignments = {};
    for (var id in selectedCourse.value!.studentIds) {
      studentAssignments[id] = "Not Submitted";
    }

    final assignment = Assignment(
      id: '', // id is generated by backend
      title: title,
      description: description,
      dueDate: dueDate,
      fileUrl: fileUrl,
      studentAssignments: studentAssignments,
    );

    await addAssignment(assignment);
    isLoading.value = false;
  }

  Future<void> addAssignment(Assignment assignment) async {
    if (selectedCourse.value == null) return;
    isLoading.value = true;
    final result = await createAssignmentUseCase.execute(
        selectedCourse.value!, assignment);
    result.fold(
      (failure) {
        Utils().showErrorSnackBar('Error', failure.failure.toString());
        isLoading.value = false;
      },
      (_) async {
        fetchAssignments(); // Refresh the list
        Get.back(); // Close dialog

        final sectionTopic =
            'Section-${selectedCourse.value?.courseSemester}-${selectedCourse.value?.courseSection}';
        await sendFCMMessage(
            sectionTopic,
            'Assignment',
            'A new ${selectedCourse.value?.courseName} assignment has been posted.\nDue Date: ${assignment.dueDate}',
            'pendingAssignment');
        Utils().showSuccessSnackBar('Success', 'Assignment added successfully');
      },
    );
  }

  Future<void> downloadAndOpenFile(String url) async {
    try {
      EasyLoading.show(status: 'Opening File...');
      String fileName = url.split('/').last;
      var response = await http.get(Uri.parse(url));

      if (response.statusCode == 200) {
        var dir = await getTemporaryDirectory();

        File file = File('${dir.path}/$fileName');
        await file.writeAsBytes(response.bodyBytes);
        OpenFile.open(file.path);
      } else {
        Utils().showErrorSnackBar('Error',
            'Failed to download file. Status code: ${response.statusCode}');
      }
    } catch (e) {
      Utils()
          .showErrorSnackBar('Error', 'Error downloading or opening file: $e');
    } finally {
      EasyLoading.dismiss();
    }
  }
}
